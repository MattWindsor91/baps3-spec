= Common Bifrost Structure

This section discusses the concepts common to all implementations
of Bifrost, the BAPS3 protocol.

== Resources

Bifrost uses a resource-tree approach to structuring the API, similar
in concept to a generalised REST.  Every action by a client on
Bifrost is specified as a _read_, _write_, or _delete_ on a resource;
every action by a server is an _update_ to an existing resource.

This approach means Bifrost has a small and consistent set of
commands, and maps well to resource-based transports such as HTTP
(which we use for REST Bifrost).

=== Actions on Resources

There are currently three actions clients can perform on resources:
_read_, _write_, and _delete_.

==== Read

Read takes a resource ID and returns its current value.  Reads *may*
map onto any action returning a value (returning a constant, querying
a file or database, and so on), so long as the following rules are
obeyed:

. Reading *must* be idempotent: two reads may only return different
  values if some action other than a read has been taken by the server
  or a client connected to it.  In other words, reading cannot change
  a resource;
. If a read returns a directory, the resources shown as belonging to
  the directory *must* be readable (unless an update has removed it);
. If a resource is readable, all of its ancestors *must* be readable
  (but *may* choose not to show the resource when read).

Resources *may* have readable children not shown when read.  This
can happen, for example, when the resource represents some sort of
search or query whose results are infinite or not easily shown.
In this case, there *should* be a readable child resource of type
+example+ that outlines a correct resource path.  For example,
a resource representing a query into a track database could have
an +example+ at resource +/tracks/{trackid}+.

==== Write

Write takes a resource ID and string representation of the intended
new value, and attempts to write it to said ID.  This may fail,
because resources can reject incompatible values.

The result of a read after a write *may* be different from the
written representation, even on success.  This can happen if there
are multiple different ways to write the same value, or if the
write triggers an action that has not yet completed when the
read in question occurs, for example.

==== Delete

Delete takes a resource ID and attempts to remove it, or set it to
its default or 'empty' value if it cannot be removed.

The value to which deletion takes a non-removable resource depends
on the resource in question.  For example, deleting +/control/state+
is equivalent to writing +Quitting+ to it.
